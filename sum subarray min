# **ðŸ“Œ Sum of Subarray Minimums â€“ Notes**  

The **Sum of Subarray Minimums** problem requires us to **find the sum of the minimum element in every possible subarray** of an array.

---

## **ðŸ”¹ Approach**
1. **Find Previous Smaller Element (PSE):**  
   - Stores the **index of the nearest smaller element to the left** for each element.
   - If no smaller element exists, store `-1`.

2. **Find Next Smaller Element (NSE):**  
   - Stores the **index of the nearest smaller element to the right** for each element.
   - If no smaller element exists, store `n` (size of array).

3. **Calculate Contribution of Each Element:**  
   - **Each element contributes as the minimum of several subarrays.**
   - Number of subarrays where `arr[i]` is the minimum:  
     - **Left Contribution** = `i - PSE[i]`
     - **Right Contribution** = `NSE[i] - i`
   - **Total contribution of `arr[i]`**:  
     \[
     (i - PSE[i]) \times (NSE[i] - i) \times arr[i]
     \]
   - Sum all contributions.

---

## **ðŸ”¹ Code Explanation**
```cpp
class Solution {
public:
    const int prime = 1e9+7; // To handle large numbers (modulo constraint)

    // Function to find Previous Smaller Element (PSE)
    vector<int> findPSE(vector<int>& a) {
        stack<int> st;
        int n = a.size();
        vector<int> pse(n);
        
        for (int i = 0; i < n; i++) {
            while (!st.empty() && a[st.top()] >= a[i]) {
                st.pop();
            }
            pse[i] = st.empty() ? -1 : st.top(); // Store index of previous smaller element
            st.push(i);
        }
        return pse;
    }

    // Function to find Next Smaller Element (NSE)
    vector<int> findNSE(vector<int>& a) {
        int n = a.size();
        stack<int> st;
        vector<int> nse(n);

        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && a[st.top()] > a[i]) {
                st.pop();
            }
            nse[i] = st.empty() ? n : st.top(); // Store index of next smaller element
            st.push(i);
        }
        return nse;
    }

    // Function to calculate sum of subarray minimums
    int sumSubarrayMins(vector<int>& a) {
        int n = a.size();
        vector<int> nse = findNSE(a);
        vector<int> pse = findPSE(a);
        int total = 0;

        for (int i = 0; i < n; i++) {
            long long left = i - pse[i];  // Number of subarrays ending at i where a[i] is min
            long long right = nse[i] - i; // Number of subarrays starting at i where a[i] is min
            total = (total + (left * right * 1LL * a[i]) % prime) % prime;
        }
        return total;
    }
};
```

---

## **ðŸ”¹ Key Observations**
âœ… **Use Monotonic Stack** â†’ Efficiently finds **previous & next smaller elements** in `O(N)`.  
âœ… **PSE & NSE help in counting subarrays where an element is the minimum.**  
âœ… **Each element's contribution is calculated using PSE & NSE values.**  
âœ… **Modulo `1e9+7` is used to prevent integer overflow.**  

---

## **ðŸ”¹ Complexity Analysis**
| Operation        | Time Complexity  | Space Complexity |
|-----------------|-----------------|------------------|
| Finding PSE     | **O(N)** | **O(N)** |
| Finding NSE     | **O(N)** | **O(N)** |
| Calculating Sum | **O(N)** | **O(1)** |
| **Total**       | **O(N)** | **O(N)** |

---

## **ðŸ”¹ Example Walkthrough**
**Input:**  
```cpp
arr = [3, 1, 2, 4]
```
### **Step 1: Compute PSE (Previous Smaller Element)**
```
Index:   0   1   2   3
Array:   3   1   2   4
PSE:    -1  -1   1   2
```
- `pse[i]` stores **the nearest smaller element index on the left**.

### **Step 2: Compute NSE (Next Smaller Element)**
```
Index:   0   1   2   3
Array:   3   1   2   4
NSE:     1   4   4   4
```
- `nse[i]` stores **the nearest smaller element index on the right**.

### **Step 3: Compute Contribution for Each Element**
\[
\text{Total Sum} = \sum (i - PSE[i]) \times (NSE[i] - i) \times arr[i]
\]
```
For i = 0: (0 - (-1)) * (1 - 0) * 3 = 1 * 1 * 3 = 3
For i = 1: (1 - (-1)) * (4 - 1) * 1 = 2 * 3 * 1 = 6
For i = 2: (2 - 1) * (4 - 2) * 2 = 1 * 2 * 2 = 4
For i = 3: (3 - 2) * (4 - 3) * 4 = 1 * 1 * 4 = 4
```
**Output:**  
\[
3 + 6 + 4 + 4 = 17
\]

---

## **ðŸ”¹ Applications of This Concept**
âœ… **Trapping Rain Water** â†’ Similar approach using `prefixMax` and `suffixMax`.  
âœ… **Sliding Window Minimum** â†’ Find min in every subarray of size `k`.  
âœ… **Largest Rectangle in Histogram** â†’ Uses `NSE` & `PSE` to find rectangle area efficiently.  
âœ… **Stock Span Problem** â†’ Uses `PSE` to determine span of stock prices.

---

## **ðŸ”¹ Key Takeaways**
ðŸ’¡ **Use a stack to efficiently find Previous Smaller Element (PSE) & Next Smaller Element (NSE).**  
ðŸ’¡ **Each element contributes as the minimum to several subarrays, which we count using PSE & NSE.**  
ðŸ’¡ **Modulo `1e9+7` prevents integer overflow in large inputs.**  
ðŸ’¡ **Optimized to `O(N)` time complexity, making it very efficient!**

ðŸš€ **Mastering this approach helps in many range-based problems!** Let me know if you need further clarification. ðŸ˜Š
